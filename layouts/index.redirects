# Netlify redirects
# Automatically generated by Hugo
# Documentation: https://docs.netlify.com/routing/redirects/

{{- /*
================================================================================
This template generates Netlify redirect rules for the site.

Two types of redirects are generated:

1. ALIAS-BASED REDIRECTS (from front matter)
   - Any page with `aliases: ["/old-path/"]` in front matter will redirect
   - This is the standard Hugo way to handle manual redirects

2. AUTOMATIC BLOG POST REDIRECTS
   - Blog posts are now at /blog/:slug/ instead of /blog/YYYY/:slug/
   - This automatically generates redirects from old year-based URLs to new ones
   - Example: /blog/2025/repo2docker-docs/ â†’ /blog/repo2docker-docs/

IMPORTANT: Slug Conflicts
- If two blog posts from different years have the same slug, they will conflict
- Hugo will build both to the same URL (last one wins)
- To fix: add `slug: "unique-name"` to the front matter of one post
- The redirects will work, but you'll have duplicate content without unique slugs

Template variables used:
- site.AllPages: All pages in the site
- .Aliases: Front matter aliases field
- site.RegularPages: All regular content pages
- .Section: The content section (e.g., "blog")
- .Date.Format "2006": Year from the page date
- .Slug: The URL slug (from filename or front matter)
- .RelPermalink: The final URL for the page

================================================================================
*/ -}}

{{ printf "\n" }}

{{- /* PART 1: Preserve existing alias-based redirects from front matter */ -}}
{{- range $page := where site.AllPages ".Aliases" "!=" nil -}}
{{- range $page.Aliases }}
{{- printf "%s %s\n" (. | relLangURL) $page.RelPermalink -}}
{{- end }}
{{- end -}}

{{- /* PART 2: Auto-generate redirects for blog posts from year-based structure */ -}}
{{- /* First, check for duplicate slugs and fail the build if found */ -}}
{{- /* Build a map of slug -> array of file paths */ -}}
{{- /* Only check published posts (skip drafts, future posts, and special pages) */ -}}
{{- $slugMap := dict -}}
{{- $blogPosts := where site.RegularPages "Section" "blog" -}}
{{- $blogPosts = where $blogPosts ".Draft" false -}}
{{- range $blogPosts -}}
{{- /* Extract the actual URL slug from RelPermalink since .Slug is empty for index.md files */ -}}
{{- $urlSlug := .RelPermalink -}}
{{- /* Skip special pages */ -}}
{{- if and (ne $urlSlug "") (not (in $urlSlug "/blog/_index")) (not (in $urlSlug "/blog/idea")) (not (in .File.Dir "/_templates/")) -}}
{{- $existing := index $slugMap $urlSlug -}}
{{- if $existing -}}
{{- $slugMap = merge $slugMap (dict $urlSlug ($existing | append .File.Path)) -}}
{{- else -}}
{{- $slugMap = merge $slugMap (dict $urlSlug (slice .File.Path)) -}}
{{- end -}}
{{- end -}}
{{- end -}}

{{- /* Check for any URL that has multiple files */ -}}
{{- $duplicateErrors := slice -}}
{{- range $url, $paths := $slugMap -}}
{{- if gt (len $paths) 1 -}}
{{- $duplicateErrors = $duplicateErrors | append (printf "  %s found in:\n    - %s" $url (delimit $paths "\n    - ")) -}}
{{- end -}}
{{- end -}}
{{- if gt (len $duplicateErrors) 0 -}}
{{- errorf "Duplicate blog post URLs found!\nMultiple posts are generating the same URL (likely due to identical titles).\n\n%s\n\nFix by adding unique 'title' or 'slug' values in the front matter of conflicting posts." (delimit $duplicateErrors "\n\n") -}}
{{- end -}}

{{- /* Now generate the redirects for published posts only */ -}}
{{- /* Need to extract folder name from path for old-style URLs */ -}}
{{- range $blogPosts -}}
{{- $year := .Date.Format "2006" -}}
{{- $urlSlug := .RelPermalink -}}
{{- if and (ne $urlSlug "") (not (in $urlSlug "/blog/_index")) (not (in $urlSlug "/blog/idea")) (not (in .File.Dir "/_templates/")) -}}
{{- /* Extract the folder name (parent dir) for the old URL structure */ -}}
{{- $pathParts := split (strings.TrimSuffix "/" .File.Dir) "/" -}}
{{- $folderSlug := index $pathParts (sub (len $pathParts) 1) -}}
{{- printf "/blog/%s/%s/ %s\n" $year $folderSlug $urlSlug -}}
{{- end }}
{{- end -}}
